

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Networking &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/asciinema-player.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory mapping" href="memory_mapping.html" />
    <link rel="prev" title="File system drivers (Part 2)" href="filesystems_part2.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Lectures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/so2.cs.pub.ro.html">Sisteme de operare 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">System Calls</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">Symmetric Multi-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="vm.html">Virtual Machine Setup</a></li>
</ul>
<p class="caption"><span class="caption-text">Labs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_modules.html">Kernel modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_api.html">Kernel API</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_drivers.html">Character device drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupts.html">I/O access and Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="deferred_work.html">Deferred work</a></li>
<li class="toctree-l1"><a class="reference internal" href="block_device_drivers.html">Block Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Networking</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#lab-objectives">Lab objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#networking-in-user-space">Networking in user space</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#linux-networking">Linux networking</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-struct-socket-structure">The <code class="docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#operations-on-the-socket-structure">Operations on the socket structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-struct-socket-fields">The <code class="docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> fields</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-struct-sock-structure">The <code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-struct-sk-buff-structure">The <code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> structure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#conversions">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#netfilter">netfilter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#netcat">netcat</a></li>
<li class="toctree-l2"><a class="reference internal" href="#further-reading">Further reading</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">Exercises</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#displaying-packets-in-kernel-space">1. Displaying packets in kernel space</a></li>
<li class="toctree-l3"><a class="reference internal" href="#filtering-by-destination-address">2. Filtering by destination address</a></li>
<li class="toctree-l3"><a class="reference internal" href="#listening-on-a-tcp-socket">3. Listening on a TCP socket</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accepting-connections-in-kernel-space">4. Accepting connections in kernel space</a></li>
<li class="toctree-l3"><a class="reference internal" href="#udp-socket-sender">5. UDP socket sender</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_model.html">Linux Device Model</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Networking</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/labs/networking.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="networking">
<h1>Networking<a class="headerlink" href="#networking" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lab-objectives">
<h2>Lab objectives<a class="headerlink" href="#lab-objectives" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>Understanding the Linux kernel networking architecture</li>
<li>Acquiring practical IP packet management skills using a packet filter or
firewall</li>
<li>Familiarize yourself with how to use sockets at the Linux kernel level</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The development of the Internet has led to an exponential increase in network
applications and, as a consequence, to increasing the speed and productivity
requirements of an operating system’s networking subsystem. The networking
subsystem is not an essential component of an operating system kernel (the Linux
kernel can be compiled without networking support). It is, however, quite
unlikely for a computing system (or even an embedded device) to have a
non-networked operating system due to the need for connectivity. Modern operating
systems use the <a class="reference external" href="https://en.wikipedia.org/wiki/Internet_protocol_suite">TCP/IP stack</a>. Their kernel
implements protocols up to the  <a class="reference external" href="https://en.wikipedia.org/wiki/Transport_layer">transport layer</a>. layer, while application layer protocols
are typically implemented in user space (HTTP, FTP, SSH, etc.).</p>
<div class="section" id="networking-in-user-space">
<h3>Networking in user space<a class="headerlink" href="#networking-in-user-space" title="Permalink to this headline">¶</a></h3>
<p>In user space the abstraction of network communication is the socket. The
socket abstracts a communication channel and is the kernel-based TCP/IP stack
interaction interface. An IP socket is associated with an IP address, the
transport layer protocol used (TCP, UDP etc) and a port. Common function calls
that use sockets are: creation (<code class="docutils literal"><span class="pre">socket</span></code>), initialization
(<code class="docutils literal"><span class="pre">bind</span></code>), connecting (<code class="docutils literal"><span class="pre">connect</span></code>), waiting for a connection
(<code class="docutils literal"><span class="pre">listen</span></code>, <code class="docutils literal"><span class="pre">accept</span></code>), closing a socket (<code class="docutils literal"><span class="pre">close</span></code>).</p>
<p>Network communication is accomplished via <code class="docutils literal"><span class="pre">read</span></code>/<code class="docutils literal"><span class="pre">write</span></code> or <code class="docutils literal"><span class="pre">recv</span></code>/<code class="docutils literal"><span class="pre">send</span></code> calls
for TCP sockets and <code class="docutils literal"><span class="pre">recvfrom</span></code>/<code class="docutils literal"><span class="pre">sendto</span></code> for UDP sockets. Transmission and
reception operations are transparent to the application, leaving encapsulation
and transmission over network at the kernel’s discretion. However, it is
possible to implement the TCP/IP stack in user space using raw sockets (the
<code class="docutils literal"><span class="pre">PF_PACKET</span></code> option when creating a socket), or implementing an application
layer protocol in kernel (<a class="reference external" href="http://en.wikipedia.org/wiki/TUX_web_server">TUX web server</a>).</p>
<p>For more details about user space programming using sockets, see <a class="reference external" href="http://www.beej.us/guide/bgnet/output/html/multipage/">Bee’s Guide to
Network Programming Using Internet
Sockets</a>.</p>
</div>
</div>
<div class="section" id="linux-networking">
<h2>Linux networking<a class="headerlink" href="#linux-networking" title="Permalink to this headline">¶</a></h2>
<p>The Linux kernel provides three basic structures for working with network
packets: <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code>, <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> and <code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">sk_buff</span></code>.</p>
<p>The first two are abstractions of a socket:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> is an abstraction very close to user space, ie <a class="reference external" href="http://en.wikipedia.org/wiki/Berkeley_sockets">BSD
sockets</a> used to program
network applications;</li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> or <em>INET socket</em> in Linux terminology is the network
representation of a socket.</li>
</ul>
</div></blockquote>
<p>The two structures are related: the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> contains an INET
socket field, and the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> has a BSD socket that holds it.</p>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> structure is the representation of a network packet
and its status. The structure is created when a kernel packet is received,
either from the user space or from the network interface.</p>
<div class="section" id="the-struct-socket-structure">
<h3>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> structure<a class="headerlink" href="#the-struct-socket-structure" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> structure is the kernel representation of a BSD
socket, the operations that can be executed on it are similar to those offered
by the kernel (through system calls). Common operations with sockets
(creation, initialization/bind, closing, etc.) result in specific system
calls; they work with the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> structure.</p>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> operations are described in <code class="file docutils literal"><span class="pre">net/socket.c</span></code> and
are independent of the protocol type. The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> structure is thus
a generic interface over particular network operations implementations.
Typically, the names of these operations begin with the <code class="docutils literal"><span class="pre">sock_</span></code> prefix.</p>
<div class="section" id="operations-on-the-socket-structure">
<span id="socketstructops"></span><h4>Operations on the socket structure<a class="headerlink" href="#operations-on-the-socket-structure" title="Permalink to this headline">¶</a></h4>
<p>Socket operations are:</p>
<div class="section" id="creation">
<h5>Creation<a class="headerlink" href="#creation" title="Permalink to this headline">¶</a></h5>
<p>Creation is similar to calling the <code class="xref c c-func docutils literal"><span class="pre">socket()</span></code> function in user space, but the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> created will be stored in the <code class="docutils literal"><span class="pre">res</span></code> parameter:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">sock_create(int</span> <span class="pre">family,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">int</span> <span class="pre">protocol,</span> <span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**res)</span></code>
creates a socket after the <code class="xref c c-func docutils literal"><span class="pre">socket()</span></code> system call;</li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">sock_create_kern(struct</span> <span class="pre">net</span> <span class="pre">*net,</span> <span class="pre">int</span> <span class="pre">family,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">int</span> <span class="pre">protocol,</span>
<span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**res)</span></code> creates a kernel socket;</li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">sock_create_lite(int</span> <span class="pre">family,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">int</span> <span class="pre">protocol,</span> <span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**res)</span></code>
creates a kernel socket without parameter sanity checks.</li>
</ul>
</div></blockquote>
<p>The parameters of these calls are as follows:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">net</span></code>, where it is present, used as reference to the network namespace used;
we will usually initialize it with <code class="docutils literal"><span class="pre">init_net</span></code>;</li>
<li><code class="docutils literal"><span class="pre">family</span></code> represents the family of protocols used in the transfer of
information; they usually begin with the <code class="docutils literal"><span class="pre">PF_</span></code> (Protocol Family) string;
the constants representing the family of protocols used are found in
<code class="file docutils literal"><span class="pre">linux/socket.h</span></code>, of which the most commonly used is <code class="docutils literal"><span class="pre">PF_INET</span></code>, for
TCP/IP protocols;</li>
<li><code class="docutils literal"><span class="pre">type</span></code> is the type of socket; the constants used for this parameter are
found in <code class="file docutils literal"><span class="pre">linux/net.h</span></code>, of which the most used are <code class="docutils literal"><span class="pre">SOCK_STREAM</span></code> for
a connection based source-to-destination communication and <code class="docutils literal"><span class="pre">SOCK_DGRAM</span></code>
for connectionless communication;</li>
<li><code class="docutils literal"><span class="pre">protocol</span></code> represents the protocol used and is closely related to the
<code class="docutils literal"><span class="pre">type</span></code> parameter; the constants used for this parameter are found in
<code class="file docutils literal"><span class="pre">linux/in.h</span></code>, of which the most used are <code class="docutils literal"><span class="pre">IPPROTO_TCP</span></code> for TCP and
<code class="docutils literal"><span class="pre">IPPROTO_UDP</span></code> for UDP.</li>
</ul>
</div></blockquote>
<p>To create a TCP socket in kernel space, you must call:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">sock_create_kern</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* handle error */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and for creating UDP sockets:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">sock_create_kern</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="n">IPPROTO_UDP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* handle error */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A usage sample is part of the <code class="xref c c-func docutils literal"><span class="pre">sys_socket()</span></code> system call handler:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
      <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

      <span class="cm">/* Check the SOCK_* constants for consistency.  */</span>
      <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SOCK_CLOEXEC</span> <span class="o">!=</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
      <span class="n">BUILD_BUG_ON</span><span class="p">((</span><span class="n">SOCK_MAX</span> <span class="o">|</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">);</span>
      <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SOCK_CLOEXEC</span> <span class="o">&amp;</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">);</span>
      <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SOCK_NONBLOCK</span> <span class="o">&amp;</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">);</span>

      <span class="n">flags</span> <span class="o">=</span> <span class="n">type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOCK_TYPE_MASK</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SOCK_CLOEXEC</span> <span class="o">|</span> <span class="n">SOCK_NONBLOCK</span><span class="p">))</span>
              <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
      <span class="n">type</span> <span class="o">&amp;=</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">SOCK_NONBLOCK</span> <span class="o">!=</span> <span class="n">O_NONBLOCK</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SOCK_NONBLOCK</span><span class="p">))</span>
              <span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOCK_NONBLOCK</span><span class="p">)</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>

      <span class="n">retval</span> <span class="o">=</span> <span class="n">sock_create</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
              <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

      <span class="k">return</span> <span class="nf">sock_map_fd</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">O_CLOEXEC</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="closing">
<h5>Closing<a class="headerlink" href="#closing" title="Permalink to this headline">¶</a></h5>
<p>Close connection (for sockets using connection) and release associated
resources:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">void</span> <span class="pre">sock_release(struct</span> <span class="pre">socket</span> <span class="pre">*sock)</span></code> calls the <code class="docutils literal"><span class="pre">release</span></code> function in
the <code class="docutils literal"><span class="pre">ops</span></code> field of the socket structure:</li>
</ul>
</div></blockquote>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">sock_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>

              <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
              <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
              <span class="n">module_put</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sending-receiving-messages">
<h5>Sending/receiving messages<a class="headerlink" href="#sending-receiving-messages" title="Permalink to this headline">¶</a></h5>
<p>The messages are sent/received using the following functions:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">sock_recvmsg(struct</span> <span class="pre">socket</span> <span class="pre">*sock,</span> <span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg,</span> <span class="pre">int</span> <span class="pre">flags);</span></code></li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">kernel_recvmsg(struct</span> <span class="pre">socket</span> <span class="pre">*sock,</span> <span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg,</span> <span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*vec,</span> <span class="pre">size_t</span> <span class="pre">num,</span> <span class="pre">size_t</span> <span class="pre">size,</span> <span class="pre">int</span> <span class="pre">flags);</span></code></li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">sock_sendmsg(struct</span> <span class="pre">socket</span> <span class="pre">*sock,</span> <span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg);</span></code></li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">kernel_sendmsg(struct</span> <span class="pre">socket</span> <span class="pre">*sock,</span> <span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg,</span> <span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*vec,</span> <span class="pre">size_t</span> <span class="pre">num,</span> <span class="pre">size_t</span> <span class="pre">size);</span></code></li>
</ul>
</div></blockquote>
<p>The message sending/receiving functions will then call the <code class="docutils literal"><span class="pre">sendmsg</span></code>/
<code class="docutils literal"><span class="pre">recvmsg</span></code> function in the <code class="docutils literal"><span class="pre">ops</span></code> field of the socket. Functions
containing <code class="docutils literal"><span class="pre">kernel_</span></code> as a prefix are used when the socket is used in the
kernel.</p>
<p>The parameters are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">msg</span></code>, a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">msghdr</span></code> structure, containing the message to be
sent/received. Among the important components of this structure are <code class="docutils literal"><span class="pre">msg_name</span></code>
and <code class="docutils literal"><span class="pre">msg_namelen</span></code>, which, for UDP sockets, must be filled in with the address
to which the message is sent (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sockaddr_in</span></code>);</li>
<li><code class="docutils literal"><span class="pre">vec</span></code>, a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kvec</span></code> structure, containing a pointer to the buffer
containing its data and size; as can be seen, it has a similar structure to the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">iovec</span></code> structure (the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">iovec</span></code> structure
corresponds to the user space data, and the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kvec</span></code> structure
corresponds to kernel space data).</li>
</ul>
</div></blockquote>
<p>A usage example can be seen in the <code class="xref c c-func docutils literal"><span class="pre">sys_sendto()</span></code> system call handler:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">sendto</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
              <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
              <span class="kt">int</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
      <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>

      <span class="n">err</span> <span class="o">=</span> <span class="n">import_single_range</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">.</span><span class="n">msg_iter</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
              <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
      <span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
              <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

      <span class="n">msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="n">msg</span><span class="p">.</span><span class="n">msg_control</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="n">msg</span><span class="p">.</span><span class="n">msg_controllen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">err</span> <span class="o">=</span> <span class="n">move_addr_to_kernel</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                      <span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
              <span class="n">msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">;</span>
              <span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="n">addr_len</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
              <span class="n">flags</span> <span class="o">|=</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>
      <span class="n">msg</span><span class="p">.</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
      <span class="n">err</span> <span class="o">=</span> <span class="n">sock_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

<span class="nl">out_put</span><span class="p">:</span>
      <span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-struct-socket-fields">
<h4>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> fields<a class="headerlink" href="#the-struct-socket-fields" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> *  struct socket - general BSD socket</span>
<span class="cm"> *  @state: socket state (%SS_CONNECTED, etc)</span>
<span class="cm"> *  @type: socket type (%SOCK_STREAM, etc)</span>
<span class="cm"> *  @flags: socket flags (%SOCK_NOSPACE, etc)</span>
<span class="cm"> *  @ops: protocol specific socket operations</span>
<span class="cm"> *  @file: File back pointer for gc</span>
<span class="cm"> *  @sk: internal networking protocol agnostic socket representation</span>
<span class="cm"> *  @wq: wait queue for several uses</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">socket</span> <span class="p">{</span>
      <span class="n">socket_state</span>            <span class="n">state</span><span class="p">;</span>

      <span class="kt">short</span>                   <span class="n">type</span><span class="p">;</span>

      <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">flags</span><span class="p">;</span>

      <span class="k">struct</span> <span class="n">socket_wq</span> <span class="n">__rcu</span>  <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

      <span class="k">struct</span> <span class="n">file</span>             <span class="o">*</span><span class="n">file</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">sock</span>             <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
      <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span>  <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The noteworthy fields are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">ops</span></code> - the structure that stores pointers to protocol-specific functions;</li>
<li><code class="docutils literal"><span class="pre">sk</span></code> - The <code class="docutils literal"><span class="pre">INET</span> <span class="pre">socket</span></code> associated with it.</li>
</ul>
</div></blockquote>
<div class="section" id="the-struct-proto-ops-structure">
<h5>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">proto_ops</span></code> structure<a class="headerlink" href="#the-struct-proto-ops-structure" title="Permalink to this headline">¶</a></h5>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">proto_ops</span></code> structure contains the implementations of the specific
operations implemented (TCP, UDP, etc.); these functions will be called from
generic functions through <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> (<code class="xref c c-func docutils literal"><span class="pre">sock_release()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">sock_sendmsg()</span></code>, etc.)</p>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">proto_ops</span></code> structure therefore contains a number of function
pointers for specific protocol implementations:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">proto_ops</span> <span class="p">{</span>
      <span class="kt">int</span>             <span class="n">family</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">module</span>   <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">);</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)</span>      <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">myaddr</span><span class="p">,</span>
                                    <span class="kt">int</span> <span class="n">sockaddr_len</span><span class="p">);</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span>
                                    <span class="kt">int</span> <span class="n">sockaddr_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">socketpair</span><span class="p">)(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock1</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock2</span><span class="p">);</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">accept</span><span class="p">)</span>    <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">kern</span><span class="p">);</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">getname</span><span class="p">)</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
                                    <span class="kt">int</span> <span class="n">peer</span><span class="p">);</span>
      <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The initialization of the <code class="docutils literal"><span class="pre">ops</span></code> field from <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> is done in
the <code class="xref c c-func docutils literal"><span class="pre">__sock_create()</span></code> function, by calling the <code class="xref c c-func docutils literal"><span class="pre">create()</span></code> function,
specific to each protocol; an equivalent call is the implementation of the
<code class="xref c c-func docutils literal"><span class="pre">__sock_create()</span></code> function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">//...</span>
      <span class="n">err</span> <span class="o">=</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">kern</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
              <span class="k">goto</span> <span class="n">out_module_put</span><span class="p">;</span>
<span class="c1">//...</span>
</pre></div>
</div>
<p>This will instantiate the function pointers with calls specific to the protocol
type associated with the socket. The <code class="xref c c-func docutils literal"><span class="pre">sock_register()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">sock_unregister()</span></code> calls are used to fill the <code class="docutils literal"><span class="pre">net_families</span></code> vector.</p>
<p>For the rest of the socket operations (other than creating, closing, and
sending/receiving a message as described above in the <a class="reference internal" href="#operations-on-the-socket-structure">Operations on the socket
structure</a> section), the functions sent via pointers in this structure will be
called. For example, for <code class="docutils literal"><span class="pre">bind</span></code>, which associates a socket with a socket on
the local machine, we will have the following code sequence:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define MY_PORT 60000</span>

<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
      <span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span> <span class="p">(</span><span class="n">MY_PORT</span><span class="p">),</span>
      <span class="p">.</span><span class="n">sin_addr</span> <span class="o">=</span> <span class="p">{</span> <span class="n">htonl</span> <span class="p">(</span><span class="n">INADDR_LOOPBACK</span><span class="p">)</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//...</span>
      <span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bind</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="cm">/* handle error */</span>
      <span class="p">}</span>
<span class="c1">//...</span>
</pre></div>
</div>
<p>As you can see, for transmitting the address and port information that
will be associated with the socket, a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sockaddr_in</span></code> is filled.</p>
</div>
</div>
</div>
<div class="section" id="the-struct-sock-structure">
<h3>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> structure<a class="headerlink" href="#the-struct-sock-structure" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> describes an <code class="docutils literal"><span class="pre">INET</span></code> socket. Such a structure is
associated with a user space socket and implicitly with a <code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">socket</span></code> structure. The structure is used to store information about the status
of a connection. The structure’s fields and associated operations usually begin
with the <code class="docutils literal"><span class="pre">sk_</span></code> string. Some fields are listed below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">sock</span> <span class="p">{</span>
      <span class="c1">//...</span>
      <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="nl">sk_padding</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="nl">sk_no_check_tx</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="nl">sk_no_check_rx</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="nl">sk_userlocks</span> <span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                              <span class="nl">sk_protocol</span>  <span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                              <span class="nl">sk_type</span>      <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
      <span class="c1">//...</span>
      <span class="k">struct</span> <span class="n">socket</span>           <span class="o">*</span><span class="n">sk_socket</span><span class="p">;</span>
      <span class="c1">//...</span>
      <span class="k">struct</span> <span class="n">sk_buff</span>          <span class="o">*</span><span class="n">sk_send_head</span><span class="p">;</span>
      <span class="c1">//...</span>
      <span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">sk_state_change</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
      <span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">sk_data_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
      <span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">sk_write_space</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
      <span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">sk_error_report</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
      <span class="kt">int</span>                     <span class="p">(</span><span class="o">*</span><span class="n">sk_backlog_rcv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
                                                <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
      <span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">sk_destruct</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p></p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">sk_protocol</span></code> is the type of protocol used by the socket;</li>
<li><code class="docutils literal"><span class="pre">sk_type</span></code> is the socket type (<code class="docutils literal"><span class="pre">SOCK_STREAM</span></code>, <code class="docutils literal"><span class="pre">SOCK_DGRAM</span></code>, etc.);</li>
<li><code class="docutils literal"><span class="pre">sk_socket</span></code> is the BSD socket that holds it;</li>
<li><code class="docutils literal"><span class="pre">sk_send_head</span></code> is the list of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> structures for
transmission;</li>
<li>the function pointers at the end are callbacks for different situations.</li>
</ul>
</div></blockquote>
<p>Initializing the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> and attaching it to a BSD socket is done
using the callback created from <code class="docutils literal"><span class="pre">net_families</span></code> (called
<code class="xref c c-func docutils literal"><span class="pre">__sock_create()</span></code>). Here’s how to initialize the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code>
structure for the IP protocol, in the <code class="xref c c-func docutils literal"><span class="pre">inet_create()</span></code> function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> *    Create an inet socket.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">inet_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
                     <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>

      <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

      <span class="c1">//...</span>
      <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
      <span class="n">sk</span> <span class="o">=</span> <span class="n">sk_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">answer_prot</span><span class="p">,</span> <span class="n">kern</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
              <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

      <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">INET_PROTOSW_REUSE</span> <span class="o">&amp;</span> <span class="n">answer_flags</span><span class="p">)</span>
              <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span> <span class="o">=</span> <span class="n">SK_CAN_REUSE</span><span class="p">;</span>


      <span class="c1">//...</span>
      <span class="n">sock_init_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

      <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span>    <span class="o">=</span> <span class="n">inet_sock_destruct</span><span class="p">;</span>
      <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span>    <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
      <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog_rcv</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">backlog_rcv</span><span class="p">;</span>
      <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="the-struct-sk-buff-structure">
<span id="structskbuff"></span><h3>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> structure<a class="headerlink" href="#the-struct-sk-buff-structure" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> (socket buffer) describes a network packet. The
structure fields contain information about both the header and packet contents,
the protocols used, the network device used, and pointers to the other
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code>. A summary description of the content of the structure
is presented below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="p">{</span>
      <span class="k">union</span> <span class="p">{</span>
              <span class="k">struct</span> <span class="p">{</span>
                      <span class="cm">/* These two members must be first. */</span>
                      <span class="k">struct</span> <span class="n">sk_buff</span>          <span class="o">*</span><span class="n">next</span><span class="p">;</span>
                      <span class="k">struct</span> <span class="n">sk_buff</span>          <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

                      <span class="k">union</span> <span class="p">{</span>
                              <span class="k">struct</span> <span class="n">net_device</span>       <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
                              <span class="cm">/* Some protocols might use this space to store information,</span>
<span class="cm">                               * while device pointer would be NULL.</span>
<span class="cm">                               * UDP receive path is one user.</span>
<span class="cm">                               */</span>
                              <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">dev_scratch</span><span class="p">;</span>
                      <span class="p">};</span>
              <span class="p">};</span>

              <span class="k">struct</span> <span class="n">rb_node</span>  <span class="n">rbnode</span><span class="p">;</span> <span class="cm">/* used in netem &amp; tcp stack */</span>
      <span class="p">};</span>
      <span class="k">struct</span> <span class="n">sock</span>             <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

        <span class="k">union</span> <span class="p">{</span>
              <span class="n">ktime_t</span>         <span class="n">tstamp</span><span class="p">;</span>
              <span class="n">u64</span>             <span class="n">skb_mstamp</span><span class="p">;</span>
      <span class="p">};</span>

      <span class="cm">/*</span>
<span class="cm">       * This is the control buffer. It is free to use for every</span>
<span class="cm">       * layer. Please put your private variables there. If you</span>
<span class="cm">       * want to keep them across layers you have to do a skb_clone()</span>
<span class="cm">       * first. This is owned by whoever has the skb queued ATM.</span>
<span class="cm">       */</span>
      <span class="kt">char</span>                    <span class="n">cb</span><span class="p">[</span><span class="mi">48</span><span class="p">]</span> <span class="n">__aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

      <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">_skb_refdst</span><span class="p">;</span>
      <span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">union</span> <span class="p">{</span>
              <span class="k">struct</span> <span class="p">{</span>
                      <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">_skb_refdst</span><span class="p">;</span>
                      <span class="kt">void</span>            <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
              <span class="p">};</span>
              <span class="k">struct</span> <span class="n">list_head</span>        <span class="n">tcp_tsorted_anchor</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="cm">/* ... */</span>

      <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">len</span><span class="p">,</span>
                              <span class="n">data_len</span><span class="p">;</span>
      <span class="n">__u16</span>                   <span class="n">mac_len</span><span class="p">,</span>
                              <span class="n">hdr_len</span><span class="p">;</span>

         <span class="cm">/* ... */</span>

      <span class="n">__be16</span>                  <span class="n">protocol</span><span class="p">;</span>
      <span class="n">__u16</span>                   <span class="n">transport_header</span><span class="p">;</span>
      <span class="n">__u16</span>                   <span class="n">network_header</span><span class="p">;</span>
      <span class="n">__u16</span>                   <span class="n">mac_header</span><span class="p">;</span>

      <span class="cm">/* private: */</span>
      <span class="n">__u32</span>                   <span class="n">headers_end</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="cm">/* public: */</span>

      <span class="cm">/* These elements must be at the end, see alloc_skb() for details.  */</span>
      <span class="n">sk_buff_data_t</span>          <span class="n">tail</span><span class="p">;</span>
      <span class="n">sk_buff_data_t</span>          <span class="n">end</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="kt">char</span>           <span class="o">*</span><span class="n">head</span><span class="p">,</span>
                              <span class="o">*</span><span class="n">data</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">truesize</span><span class="p">;</span>
      <span class="n">refcount_t</span>              <span class="n">users</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">next</span></code> and <code class="docutils literal"><span class="pre">prev</span></code> are pointers to the next, and previous element in the
buffer list;</li>
<li><code class="docutils literal"><span class="pre">dev</span></code> is the device which sends or receives the buffer;</li>
<li><code class="docutils literal"><span class="pre">sk</span></code> is the socket associated with the buffer;</li>
<li><code class="docutils literal"><span class="pre">destructor</span></code> is the callback that deallocates the buffer;</li>
<li><code class="docutils literal"><span class="pre">transport_header</span></code>, <code class="docutils literal"><span class="pre">network_header</span></code>, and <code class="docutils literal"><span class="pre">mac_header</span></code> are offsets
between the beginning of the packet and the beginning of the various headers
in the packets. They are internally maintained by the various processing
layers through which the packet passes. To get pointers to the headers, use
one of the following functions: <code class="xref c c-func docutils literal"><span class="pre">tcp_hdr()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">udp_hdr()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">ip_hdr()</span></code>, etc. In principle, each protocol provides a function to
get a reference to the header of that protocol within a received packet.
Keep in mind that the <code class="docutils literal"><span class="pre">network_header</span></code> field is not set until the packet
reaches the network layer and the <code class="docutils literal"><span class="pre">transport_header</span></code> field is not set
until the packet reaches the transport layer.</li>
</ul>
</div></blockquote>
<p>The structure of an <a class="reference external" href="https://en.wikipedia.org/wiki/IPv4#Header">IP header</a>
(<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">iphdr</span></code>) has the following fields:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">iphdr</span> <span class="p">{</span>
<span class="cp">#if defined(__LITTLE_ENDIAN_BITFIELD)</span>
      <span class="n">__u8</span>    <span class="nl">ihl</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">version</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>
<span class="cp">#elif defined (__BIG_ENDIAN_BITFIELD)</span>
      <span class="n">__u8</span>    <span class="nl">version</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">ihl</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#error        &quot;Please fix &lt;asm/byteorder.h&gt;&quot;</span>
<span class="cp">#endif</span>
      <span class="n">__u8</span>    <span class="n">tos</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">tot_len</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">id</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">frag_off</span><span class="p">;</span>
      <span class="n">__u8</span>    <span class="n">ttl</span><span class="p">;</span>
      <span class="n">__u8</span>    <span class="n">protocol</span><span class="p">;</span>
      <span class="n">__sum16</span> <span class="n">check</span><span class="p">;</span>
      <span class="n">__be32</span>  <span class="n">saddr</span><span class="p">;</span>
      <span class="n">__be32</span>  <span class="n">daddr</span><span class="p">;</span>
      <span class="cm">/*The options start here. */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">protocol</span></code> is the transport layer protocol used;</li>
<li><code class="docutils literal"><span class="pre">saddr</span></code> is the source IP address;</li>
<li><code class="docutils literal"><span class="pre">daddr</span></code> is the destination IP address.</li>
</ul>
</div></blockquote>
<p>The structure of a <a class="reference external" href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">TCP header</a>
(<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">tcphdr</span></code>) has the following fields:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">tcphdr</span> <span class="p">{</span>
      <span class="n">__be16</span>  <span class="n">source</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">dest</span><span class="p">;</span>
      <span class="n">__be32</span>  <span class="n">seq</span><span class="p">;</span>
      <span class="n">__be32</span>  <span class="n">ack_seq</span><span class="p">;</span>
<span class="cp">#if defined(__LITTLE_ENDIAN_BITFIELD)</span>
      <span class="n">__u16</span>   <span class="nl">res1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">doff</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">fin</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">syn</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">rst</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">psh</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">ack</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">urg</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">ece</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">cwr</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#elif defined(__BIG_ENDIAN_BITFIELD)</span>
      <span class="n">__u16</span>   <span class="nl">doff</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">res1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">cwr</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">ece</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">urg</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">ack</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">psh</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">rst</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">syn</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">fin</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#error        &quot;Adjust your &lt;asm/byteorder.h&gt; defines&quot;</span>
<span class="cp">#endif</span>
      <span class="n">__be16</span>  <span class="n">window</span><span class="p">;</span>
      <span class="n">__sum16</span> <span class="n">check</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">urg_ptr</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">source</span></code> is the source port;</li>
<li><code class="docutils literal"><span class="pre">dest</span></code> is the destination port;</li>
<li><code class="docutils literal"><span class="pre">syn</span></code>, <code class="docutils literal"><span class="pre">ack</span></code>, <code class="docutils literal"><span class="pre">fin</span></code> are the TCP flags used; for a more detailed view,
see this <a class="reference external" href="http://www.eventhelix.com/Realtimemantra/Networking/Tcp.pdf">diagram</a>.</li>
</ul>
</div></blockquote>
<p>The structure of a <a class="reference external" href="https://en.wikipedia.org/wiki/User_Datagram_Protocol#Packet_structure">UDP header</a>
(<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">udphdr</span></code>) has the following fields:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">udphdr</span> <span class="p">{</span>
      <span class="n">__be16</span>  <span class="n">source</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">dest</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">len</span><span class="p">;</span>
      <span class="n">__sum16</span> <span class="n">check</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">source</span></code> is the source port;</li>
<li><code class="docutils literal"><span class="pre">dest</span></code> is the destination port.</li>
</ul>
</div></blockquote>
<p>An example of accessing the information present in the headers of a network
packet is as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>                 <span class="cm">/* IP header */</span>
<span class="cm">/* iph-&gt;saddr  - source IP address */</span>
<span class="cm">/* iph-&gt;daddr  - destination IP address */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span> <span class="p">{</span>              <span class="cm">/* TCP protocol */</span>
        <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">tcph</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>      <span class="cm">/* TCP header */</span>
        <span class="cm">/* tcph-&gt;source  - source TCP port */</span>
        <span class="cm">/* tcph-&gt;dest    - destination TCP port */</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span> <span class="p">{</span>       <span class="cm">/* UDP protocol */</span>
        <span class="k">struct</span> <span class="n">udphdr</span> <span class="o">*</span><span class="n">udph</span> <span class="o">=</span> <span class="n">udp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>      <span class="cm">/* UDP header */</span>
        <span class="cm">/* udph-&gt;source  - source UDP port */</span>
        <span class="cm">/* udph-&gt;dest    - destination UDP port */</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="conversions">
<span id="id1"></span><h2>Conversions<a class="headerlink" href="#conversions" title="Permalink to this headline">¶</a></h2>
<p>In different systems, there are several ways of ordering bytes in a word
(<a class="reference external" href="http://en.wikipedia.org/wiki/Endianness">Endianness</a>), including: <a class="reference external" href="http://en.wikipedia.org/wiki/Endianness#Big-endian">Big
Endian</a> (the most
significant byte first) and <a class="reference external" href="http://en.wikipedia.org/wiki/Endianness#Little-endian">Little
Endian</a> (the least
significant byte first). Since a network interconnects systems with different
platforms, the Internet has imposed a standard sequence for the storage of
numerical data, called <a class="reference external" href="http://en.wikipedia.org/wiki/Endianness#Endianness_in_networking">network byte-order</a>. In
contrast, the byte sequence for the representation of numerical data on the host
computer is called host byte-order. Data received/sent from/to the network is in
the network byte-order format and should be converted between this format and
the host byte-order.</p>
<p>For converting we use the following macros:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">u16</span> <span class="pre">htons(u16</span> <span class="pre">x)</span></code> converts a 16 bit integer from host byte-order to
network byte-order (host to network short);</li>
<li><code class="docutils literal"><span class="pre">u32</span> <span class="pre">htonl(u32</span> <span class="pre">x)</span></code> converts a 32 bit integer from host byte-order to
network byte-order (host to network long);</li>
<li><code class="docutils literal"><span class="pre">u16</span> <span class="pre">ntohs(u16</span> <span class="pre">x)</span></code> converts a 16 bit integer from network byte-order to
host byte-order (network to host short);</li>
<li><code class="docutils literal"><span class="pre">u32</span> <span class="pre">ntohl(u32</span> <span class="pre">x)</span></code> converts a 32 bit integer from network byte-order to
host byte-order (network to host long).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="netfilter">
<span id="id2"></span><h2>netfilter<a class="headerlink" href="#netfilter" title="Permalink to this headline">¶</a></h2>
<p>Netfilter is the name of the kernel interface for capturing network packets for
modifying/analyzing them (for filtering, NAT, etc.). <a class="reference external" href="http://www.netfilter.org/">The netfilter</a> interface is used in user space by <a class="reference external" href="http://www.frozentux.net/documents/iptables-tutorial/">iptables</a>.</p>
<p>In the Linux kernel, packet capture using netfilter is done by attaching hooks.
Hooks can be specified in different locations in the path followed by a kernel
network packet, as needed. An organization chart with the route followed by a
package and the possible areas for a hook can be found <a class="reference external" href="http://linux-ip.net/nf/nfk-traversal.png">here</a>.</p>
<p>The header included when using netfilter is <code class="file docutils literal"><span class="pre">linux/netfilter.h</span></code>.</p>
<p>A hook is defined through the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">nf_hook_ops</span></code> structure:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="p">{</span>
      <span class="cm">/* User fills in from here down. */</span>
      <span class="n">nf_hookfn</span>               <span class="o">*</span><span class="n">hook</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">net_device</span>       <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
      <span class="kt">void</span>                    <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
      <span class="n">u_int8_t</span>                <span class="n">pf</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">hooknum</span><span class="p">;</span>
      <span class="cm">/* Hooks are ordered in ascending priority. */</span>
      <span class="kt">int</span>                     <span class="n">priority</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">pf</span></code> is the package type (<code class="docutils literal"><span class="pre">PF_INET</span></code>, etc.);</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">priority</span></code> is the priority; priorities are defined in</dt>
<dd><code class="file docutils literal"><span class="pre">uapi/linux/netfilter_ipv4.h</span></code> as follows:</dd>
</dl>
</li>
</ul>
</div></blockquote>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">nf_ip_hook_priorities</span> <span class="p">{</span>
      <span class="n">NF_IP_PRI_FIRST</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_CONNTRACK_DEFRAG</span> <span class="o">=</span> <span class="o">-</span><span class="mi">400</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_RAW</span> <span class="o">=</span> <span class="o">-</span><span class="mi">300</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_SELINUX_FIRST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">225</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_CONNTRACK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">200</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_MANGLE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">150</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_NAT_DST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_FILTER</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_SECURITY</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_NAT_SRC</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_SELINUX_LAST</span> <span class="o">=</span> <span class="mi">225</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_CONNTRACK_HELPER</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_CONNTRACK_CONFIRM</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_LAST</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p></p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">net_device</span></code> is the device (network interface) on which the capture is
intended;</li>
<li><code class="docutils literal"><span class="pre">hooknum</span></code> is the type of hook used. When a packet is captured, the
processing mode is defined by the <code class="docutils literal"><span class="pre">hooknum</span></code> and <code class="docutils literal"><span class="pre">hook</span></code> fields. For IP,
hook types are defined in <code class="file docutils literal"><span class="pre">linux/netfilter.h</span></code>:</li>
</ul>
</div></blockquote>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">nf_inet_hooks</span> <span class="p">{</span>
      <span class="n">NF_INET_PRE_ROUTING</span><span class="p">,</span>
      <span class="n">NF_INET_LOCAL_IN</span><span class="p">,</span>
      <span class="n">NF_INET_FORWARD</span><span class="p">,</span>
      <span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span>
      <span class="n">NF_INET_POST_ROUTING</span><span class="p">,</span>
      <span class="n">NF_INET_NUMHOOKS</span>
<span class="p">};</span>
</pre></div>
</div>
<p></p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">hook</span></code> is the handler called when capturing a network packet (packet sent
as a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> structure). The <code class="docutils literal"><span class="pre">private</span></code> field is private information
handed to the handler. The capture handler prototype is defined by the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">nf_hookfn</span></code> type:</li>
</ul>
</div></blockquote>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">nf_hook_state</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">;</span>
      <span class="n">u_int8_t</span> <span class="n">pf</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">nf_hookfn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
                             <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                             <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_state</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
</pre></div>
</div>
<p>For the <code class="xref c c-func docutils literal"><span class="pre">nf_hookfn()</span></code> capture function, the <code class="docutils literal"><span class="pre">priv</span></code> field is the private
information with which the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">nf_hook_ops</span></code> was initialized. <code class="docutils literal"><span class="pre">skb</span></code>
is the pointer to the captured network packet. Based on <code class="docutils literal"><span class="pre">skb</span></code> information,
packet filtering decisions are made. The function’s <code class="docutils literal"><span class="pre">state</span></code> parameter is the
status information related to the packet capture, including the input interface,
the output interface, the priority, the hook number. Priority and hook number
are useful for allowing the same function to be called by several hooks.</p>
<p>A capture handler can return one of the constants <code class="docutils literal"><span class="pre">NF_*</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* Responses from hook functions. */</span>
<span class="cp">#define NF_DROP 0</span>
<span class="cp">#define NF_ACCEPT 1</span>
<span class="cp">#define NF_STOLEN 2</span>
<span class="cp">#define NF_QUEUE 3</span>
<span class="cp">#define NF_REPEAT 4</span>
<span class="cp">#define NF_STOP 5</span>
<span class="cp">#define NF_MAX_VERDICT NF_STOP</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">NF_DROP</span></code> is used to filter (ignore) a packet, and <code class="docutils literal"><span class="pre">NF_ACCEPT</span></code> is used to
accept a packet and forward it.</p>
<p>Registering/unregistering a hook is done using the functions defined in
<code class="file docutils literal"><span class="pre">linux/netfilter.h</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* Function to register/unregister hook points. */</span>
<span class="kt">int</span> <span class="nf">nf_register_net_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">nf_unregister_net_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">nf_register_net_hooks</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span>
                        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">nf_unregister_net_hooks</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span>
                           <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>There are some restrictions related to the use of header extraction functions
from a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> structure set as a parameter in a netfilter
hook. While the IP header can be obtained each time using <code class="xref c c-func docutils literal"><span class="pre">ip_hdr()</span></code>,
the TCP and UDP headers can be obtained with <code class="xref c c-func docutils literal"><span class="pre">tcp_hdr()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">udp_hdr()</span></code> only for packages that come from inside the system rather
than the ones that are received from outside the system. In the latter case,
you must manually calculate the header offset in the package:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// For TCP packets (iph-&gt;protocol == IPPROTO_TCP)</span>
<span class="n">tcph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="o">*</span><span class="p">)((</span><span class="n">__u32</span><span class="o">*</span><span class="p">)</span><span class="n">iph</span> <span class="o">+</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">);</span>
<span class="c1">// For UDP packets (iph-&gt;protocol == IPPROTO_UDP)</span>
<span class="n">udph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span><span class="o">*</span><span class="p">)((</span><span class="n">__u32</span><span class="o">*</span><span class="p">)</span><span class="n">iph</span> <span class="o">+</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">);</span>
</pre></div>
</div>
<p class="last">This code works in all filtering situations, so it’s recommended to use it
instead of header access functions.</p>
</div>
<p>A usage example for a netfilter hook is shown below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/netfilter.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/netfilter_ipv4.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/net.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/in.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/skbuff.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/ip.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/tcp.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">my_nf_hookfn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
              <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
              <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
      <span class="cm">/* process packet */</span>
      <span class="c1">//...</span>

      <span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="n">my_nfho</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">.</span><span class="n">hook</span>        <span class="o">=</span> <span class="n">my_nf_hookfn</span><span class="p">,</span>
      <span class="p">.</span><span class="n">hooknum</span>     <span class="o">=</span> <span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span>
      <span class="p">.</span><span class="n">pf</span>          <span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
      <span class="p">.</span><span class="n">priority</span>    <span class="o">=</span> <span class="n">NF_IP_PRI_FIRST</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_hook_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
      <span class="k">return</span> <span class="n">nf_register_net_hook</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_nfho</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_hook_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">nf_unregister_net_hook</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_nfho</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">my_hook_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">my_hook_exit</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="netcat">
<h2>netcat<a class="headerlink" href="#netcat" title="Permalink to this headline">¶</a></h2>
<p>When developing applications that include networking code, one of the most
used tools is netcat. Also nicknamed “Swiss-army knife for TCP / IP”. It allows:</p>
<blockquote>
<div><ul class="simple">
<li>Initiating TCP connections;</li>
<li>Waiting for a TCP connection;</li>
<li>Sending and receiving UDP packets;</li>
<li>Displaying traffic in hexdump format;</li>
<li>Run a program after establishing a connection (eg, a shell);</li>
<li>Set special options in sent packages.</li>
</ul>
</div></blockquote>
<p>Initiating TCP connections:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">nc hostname port</span>
</pre></div>
</div>
<p>Listening to a TCP port:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">nc -l -p port</span>
</pre></div>
</div>
<p>Sending and receiving UDP packets is done adding the <code class="docutils literal"><span class="pre">-u</span></code> command line option.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The command is <strong class="command">nc</strong>; often <strong class="command">netcat</strong> is an alias for this
command. There are other implementations of the netcat command, some of which
have slightly different parameters than the classic implementation. Run
<strong class="command">man nc</strong> or <strong class="command">nc -h</strong> to check how to use it.</p>
</div>
<p>For more information on netcat, check the following <a class="reference external" href="https://www.win.tue.nl/~aeb/linux/hh/netcat_tutorial.pdf">tutorial</a>.</p>
</div>
<div class="section" id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Understanding Linux Network Internals</li>
<li><a class="reference external" href="http://www.cs.unh.edu/cnrg/gherrin/">Linux IP networking</a></li>
<li><a class="reference external" href="http://www.stllinux.org/meeting_notes/2001/0719/myTUX/">The TUX Web Server</a></li>
<li><a class="reference external" href="http://beej.us/net2/bgnet.html">Beej’s Guide to Network Programming Using Internet Sockets</a></li>
<li><a class="reference external" href="http://www.linuxjournal.com/article/7660">Kernel Korner - Network Programming in the Kernel</a></li>
<li><a class="reference external" href="http://phrack.org/issues/61/13.html">Hacking the Linux Kernel Network Stack</a></li>
<li><a class="reference external" href="http://www.netfilter.org/">The netfilter.org project</a></li>
<li><a class="reference external" href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture">A Deep Dive Into Iptables and Netfilter Architecture</a></li>
<li><a class="reference external" href="http://www.linuxfoundation.org/en/Net:Main_Page">Linux Foundation Networking Page</a></li>
</ol>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>To solve exercises, you need to perform these steps:</p>
<blockquote>
<div><ul class="simple">
<li>prepare skeletons from templates</li>
<li>build modules</li>
<li>copy modules to the VM</li>
<li>start the VM and test the module in the VM.</li>
</ul>
</div></blockquote>
<p>The current lab name is networking. See the exercises for the task name.</p>
<div class="toggle last docutils container">
<div class="header docutils container">
<strong>See details</strong></div>
<p>The skeleton code is generated from full source examples located in
<code class="file docutils literal"><span class="pre">tools/labs/templates</span></code>. To solve the tasks, start by generating
the skeleton code:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>where task name is defined for each task. Once the skeleton drivers are
generated, build the source:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>Then, copy the modules and start the VM:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>The modules are placed in /home/root/skels/networking/&lt;task_name&gt;.</p>
<p>Alternatively, we can copy files via <strong class="command">scp</strong>, in order to avoid restarting the VM.
For additional details about connecting to the VM via the network, please check <a class="reference internal" href="vm.html#vm-interaction-link"><span class="std std-ref">Connecting to the VM</span></a>.</p>
<p>Review the <a class="reference internal" href="#exercises">Exercises</a> section for more detailed information.</p>
</div>
</div>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">You need to make sure that the <code class="docutils literal"><span class="pre">netfilter</span></code> support is active in kernel. It
is enabled via <code class="docutils literal"><span class="pre">CONFIG_NETFILTER</span></code>. To activate it, run <strong class="command">make menuconfig</strong> in
the <code class="file docutils literal"><span class="pre">linux</span></code> directory and check the <code class="docutils literal"><span class="pre">Network</span> <span class="pre">packet</span> <span class="pre">filtering</span> <span class="pre">framework</span>
<span class="pre">(Netfilter)</span></code> option in <code class="docutils literal"><span class="pre">Networking</span> <span class="pre">support</span> <span class="pre">-&gt;</span> <span class="pre">Networking</span> <span class="pre">options</span></code>. If it
was not enabled, enable it (as builtin, not external module - it must be
marked with <code class="docutils literal"><span class="pre">*</span></code>).</p>
</div>
<div class="section" id="displaying-packets-in-kernel-space">
<h3>1. Displaying packets in kernel space<a class="headerlink" href="#displaying-packets-in-kernel-space" title="Permalink to this headline">¶</a></h3>
<p>Write a kernel module that displays the source address and port for TCP packets
that initiate an outbound connection. Start from the code in
<code class="file docutils literal"><span class="pre">1-2-netfilter</span></code> and fill in the areas marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code>, taking into
account the comments below.</p>
<p>You will need to register a netfilter hook of type <code class="docutils literal"><span class="pre">NF_INET_LOCAL_OUT</span></code> as explained
in the <a class="reference internal" href="#netfilter">netfilter</a> section.</p>
<p><a class="reference internal" href="#the-struct-sk-buff-structure">The struct sk_buff structure</a> lets you access the packet headers using
specific functions. The <code class="xref c c-func docutils literal"><span class="pre">ip_hdr()</span></code> function returns the IP header as a
pointer to a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">iphdr</span></code> structure. The <code class="xref c c-func docutils literal"><span class="pre">tcp_hdr()</span></code> function
returns the TCP header as a pointer to a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">tcphdr</span></code> structure.</p>
<p>The <a class="reference external" href="http://www.eventhelix.com/Realtimemantra/Networking/Tcp.pdf">diagram</a> explains how to make a TCP connection. The connection initiation
packet has the <code class="docutils literal"><span class="pre">SYN</span></code> flag set in the TCP header and the <code class="docutils literal"><span class="pre">ACK</span></code> flag cleared.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>To display the source IP address, use the <code class="docutils literal"><span class="pre">%pI4</span></code> format of the printk
function. Details can be found in the <a class="reference external" href="https://www.kernel.org/doc/Documentation/printk-formats.txt">kernel documentation</a> (<code class="docutils literal"><span class="pre">IPv4</span>
<span class="pre">addresses</span></code> section). The following is an example code snippet that uses
<code class="docutils literal"><span class="pre">%pI4</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;IP address is %pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">);</span>
</pre></div>
</div>
<p class="last">When using the <code class="docutils literal"><span class="pre">%pI4</span></code> format, the argument to printk is a pointer. Hence the
construction <code class="docutils literal"><span class="pre">&amp;iph-&gt;saddr</span></code> (with operator &amp; - ampersand) instead of
<code class="docutils literal"><span class="pre">iph-&gt;saddr</span></code>.</p>
</div>
<p>The source TCP port is, in the TCP header, in the <a class="reference external" href="http://en.wikipedia.org/wiki/Endianness#Endianness_in_networking">network byte-order</a> format.
Read through the <a class="reference internal" href="#conversions"><span class="std std-ref">Conversions</span></a> section. Use <code class="xref c c-func docutils literal"><span class="pre">ntohs()</span></code> to convert.</p>
<p>For testing, use the <code class="file docutils literal"><span class="pre">1-2-netfilter/user/test-1.sh</span></code> file. The test creates
a connection to the localhost, a connection that will be intercepted and
displayed by the kernel module. The script is copied on the virtual machine by
the <strong class="command">make copy</strong> command only if it is marked as executable. The script
uses the statically compiled <strong class="command">netcat</strong> tool stored in
<code class="file docutils literal"><span class="pre">skels/networking/netcat</span></code>; this program must have execution
permissions.</p>
<p>After running the checker the output should be similar to the one bellow:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp"># ./test-1.sh</span>
<span class="p">[</span>  <span class="mf">229.783512</span><span class="p">]</span> <span class="n">TCP</span> <span class="n">connection</span> <span class="n">initiated</span> <span class="n">from</span> <span class="mf">127.0.0.1</span><span class="o">:</span><span class="mi">44716</span>
<span class="n">Should</span> <span class="n">show</span> <span class="n">up</span> <span class="n">in</span> <span class="n">filter</span><span class="p">.</span>
<span class="n">Check</span> <span class="n">dmesg</span> <span class="n">output</span><span class="p">.</span>
</pre></div>
</div>
</div>
<div class="section" id="filtering-by-destination-address">
<h3>2. Filtering by destination address<a class="headerlink" href="#filtering-by-destination-address" title="Permalink to this headline">¶</a></h3>
<p>Extend the module from exercise 1 so that you can specify a destination address
by means of a <code class="docutils literal"><span class="pre">MY_IOCTL_FILTER_ADDRESS</span></code> ioctl call. You’ll only show packages
containing the specified destination address. To solve this task, fill in the
areas marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code> and follow the specifications below.</p>
<p>To implement the ioctl routine, you must fill out the <code class="docutils literal"><span class="pre">my_ioctl</span></code> function.
Review the section in <a class="reference internal" href="device_drivers.html#ioctl"><span class="std std-ref">ioctl</span></a>. The address sent from user space is in
<a class="reference external" href="http://en.wikipedia.org/wiki/Endianness#Endianness_in_networking">network byte-order</a>, so there will be <strong>NO need</strong> for conversion.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The IP address sent via <code class="docutils literal"><span class="pre">ioctl</span></code> is sent by address, not by value. The
address must be stored in the <code class="docutils literal"><span class="pre">ioctl_set_addr</span></code> variable. For copying use
<code class="xref c c-func docutils literal"><span class="pre">copy_from_user()</span></code>.</p>
</div>
<p>To compare the addresses, fill out the <code class="docutils literal"><span class="pre">test_daddr</span></code> function. Addresses in
network byte-order will be used without having to convert addresses (if they
are equal from left to right they will be equal if reversed too).</p>
<p>The <code class="docutils literal"><span class="pre">test_daddr</span></code> function must be called from the netfilter hook to display
the connection initialization packets for which the destination address is the
one sent through the ioctl routine. The connection initiation packet has the
<code class="docutils literal"><span class="pre">SYN</span></code> flag set in the TCP header and the <code class="docutils literal"><span class="pre">ACK</span></code> flag cleared.  You have to
check two things:</p>
<blockquote>
<div><ul class="simple">
<li>the TCP flags;</li>
<li>the destination address of the packet (using <code class="docutils literal"><span class="pre">test_addr</span></code>).</li>
</ul>
</div></blockquote>
<p>For testing, use the <code class="file docutils literal"><span class="pre">1-2-netfilter/user/test-2.sh</span></code> script. This script
needs to compile the <code class="file docutils literal"><span class="pre">1-2-netfilter/user/test.c</span></code> file in the test
executable. Compilation is done automatically on the physical system when
running the <strong class="command">make build</strong> command. The test script is copied to the
virtual machine only if it is marked as executable. The script uses the
statically compiled <strong class="command">netcat</strong> tool in <code class="file docutils literal"><span class="pre">skels/networking/netcat</span></code>;
this executable must have execution permissions.</p>
<p>After running the checker the output should be similar to the one bellow:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./test-2.sh
<span class="go">[  797.673535] TCP connection initiated from 127.0.0.1:44721</span>
<span class="go">Should show up in filter.</span>
<span class="go">Should NOT show up in filter.</span>
<span class="go">Check dmesg output.</span>
</pre></div>
</div>
<p>The test ask for packet filtering first for the <code class="docutils literal"><span class="pre">127.0.0.1</span></code> IP address and
then for the <code class="docutils literal"><span class="pre">127.0.0.2</span></code> IP address. The first connection initiation packet
(to <code class="docutils literal"><span class="pre">127.0.0.1</span></code>) is intercepted and displayed by the filter, while the second
(to <code class="docutils literal"><span class="pre">127.0.0.2</span></code>) is not intercepted.</p>
</div>
<div class="section" id="listening-on-a-tcp-socket">
<h3>3. Listening on a TCP socket<a class="headerlink" href="#listening-on-a-tcp-socket" title="Permalink to this headline">¶</a></h3>
<p>Write a kernel module that creates a TCP socket that listens to connections on
port <code class="docutils literal"><span class="pre">60000</span></code> on the loopback interface (in <code class="docutils literal"><span class="pre">init_module</span></code>). Start from the
code in <code class="file docutils literal"><span class="pre">3-4-tcp-sock</span></code> fill in the areas marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code> taking
into account the observations below.</p>
<p>Read the <a class="reference internal" href="#operations-on-the-socket-structure">Operations on the socket structure</a> and <a class="reference internal" href="#the-struct-proto-ops-structure">The struct proto_ops
structure</a> sections.</p>
<p>The <code class="docutils literal"><span class="pre">sock</span></code> socket is a <code class="docutils literal"><span class="pre">server</span> <span class="pre">socket</span></code> and must be put in the listening
state. That is, the <code class="docutils literal"><span class="pre">bind</span></code> and <code class="docutils literal"><span class="pre">listen</span></code> operations must be applied to the
socket. For the <code class="docutils literal"><span class="pre">bind</span></code> and <code class="docutils literal"><span class="pre">listen</span></code> equivalent, in kernel space you will
need to call <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;...;</span></code> examples of such functions you can call are
<code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;bind</span></code>, <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;listen</span></code> etc.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For example, call <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;bind</span></code>, or <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;listen</span></code> functions, see
how they are called in the <code class="xref c c-func docutils literal"><span class="pre">sys_bind()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_listen()</span></code> system
call handlers.</p>
<p class="last">Look for the system call handlers in the <code class="docutils literal"><span class="pre">net/socket.c</span></code> file in the Linux
kernel source code tree.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For the second argument of the <code class="docutils literal"><span class="pre">listen</span></code> (backlog) call, use the
<code class="docutils literal"><span class="pre">LISTEN_BACKLOG</span></code>.</p>
</div>
<p>Remember to release the socket in the module’s exit function and in the area
marked with error labels; use <code class="xref c c-func docutils literal"><span class="pre">sock_release()</span></code>.</p>
<p>For testing, run the <strong class="command">3-4-tcp_sock/test-3.sh</strong> script. The script is
copied on the virtual machine by <strong class="command">make copy</strong> only if it is marked as
executable.</p>
<p>After running the test, a TCP socket will be displayed by listening to
connections on port <code class="docutils literal"><span class="pre">60000</span></code>.</p>
</div>
<div class="section" id="accepting-connections-in-kernel-space">
<h3>4. Accepting connections in kernel space<a class="headerlink" href="#accepting-connections-in-kernel-space" title="Permalink to this headline">¶</a></h3>
<p>Expand the module from the previous exercise to allow an external connection (no
need to send any message, only accept new connections). Fill in the areas marked
with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code>.</p>
<p>Read the <a class="reference internal" href="#operations-on-the-socket-structure">Operations on the socket structure</a> and <a class="reference internal" href="#the-struct-proto-ops-structure">The struct proto_ops
structure</a> sections.</p>
<p>For the kernel space <code class="docutils literal"><span class="pre">accept</span></code> equivalent, see the system call handler for
<code class="xref c c-func docutils literal"><span class="pre">sys_accept4()</span></code>. Follow the <code class="xref c c-func docutils literal"><span class="pre">lnet_sock_accept()</span></code> implementation, and
how the <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;accept</span></code> call is used. Use <code class="docutils literal"><span class="pre">0</span></code> as the value for the
second to last argument (<code class="docutils literal"><span class="pre">flags</span></code>), and <code class="docutils literal"><span class="pre">true</span></code> for the last argument
(<code class="docutils literal"><span class="pre">kern</span></code>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Look for the system call handlers in the <code class="docutils literal"><span class="pre">net/socket.c</span></code> file in the Linux
kernel source code tree.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The new socket (<code class="docutils literal"><span class="pre">new_sock</span></code>) must be created with the
<code class="xref c c-func docutils literal"><span class="pre">sock_create_lite()</span></code> function and then its operations must be configured
using</p>
<div class="last highlight-console"><div class="highlight"><pre><span></span><span class="go">newsock-&gt;ops = sock-&gt;ops;</span>
</pre></div>
</div>
</div>
<p>Print the address and port of the destination socket. To find the peer name of a
socket (its address), refer to the <code class="xref c c-func docutils literal"><span class="pre">sys_getpeername()</span></code> system call handler.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The first argument for the <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;getname</span></code> function will be the
connection socket, ie <code class="docutils literal"><span class="pre">new_sock</span></code>, the one initialized with by the <code class="docutils literal"><span class="pre">accept</span></code>
call.</p>
<p>The last argument of the <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;getname</span></code> function will be <code class="docutils literal"><span class="pre">1</span></code>,
meaning that we want to know about the endpoint or the peer (<em>remote end</em> or
<em>peer</em>).</p>
<p class="last">Display the peer address (indicated by the <code class="docutils literal"><span class="pre">raddr</span></code> variable) using the
<code class="docutils literal"><span class="pre">print_sock_address</span></code> macro defined in the file.</p>
</div>
<p>Release the newly created socket (after accepting the connection) in the module
exit function and after the error label. After adding the <code class="docutils literal"><span class="pre">accept</span></code> code to the
module initialization function, the <strong class="command">insmod</strong> operation will lock until
a connection is established. You can unlock using <strong class="command">netcat</strong> on that
port. Consequently, the test script from the previous exercise will not work.</p>
<p>For testing, run the <code class="file docutils literal"><span class="pre">3-4-tcp_sock/test-4.sh</span></code> script. The script is copied on
the virtual machine by <strong class="command">make copy</strong> only if it is marked as executable.</p>
<p>Nothing special will be displayed (in the kernel buffer). The success of the
test will be defined by the connection establishment. Then use <code class="docutils literal"><span class="pre">Ctrl+c</span></code> to
stop the test script, and then you can remove the kernel module.</p>
</div>
<div class="section" id="udp-socket-sender">
<h3>5. UDP socket sender<a class="headerlink" href="#udp-socket-sender" title="Permalink to this headline">¶</a></h3>
<p>Write a kernel module that creates a UDP socket and sends the message from the
<code class="docutils literal"><span class="pre">MY_TEST_MESSAGE</span></code> macro on the socket to the loopback address on port
<code class="docutils literal"><span class="pre">60001</span></code>.</p>
<p>Start from the code in <code class="file docutils literal"><span class="pre">5-udp-sock</span></code>.</p>
<p>Read the <a class="reference internal" href="#operations-on-the-socket-structure">Operations on the socket structure</a> and <a class="reference internal" href="#the-struct-proto-ops-structure">The struct proto_ops
structure</a> sections.</p>
<p>To see how to send messages in the kernel space, see the <code class="xref c c-func docutils literal"><span class="pre">sys_send()</span></code>
system call handler or <a class="reference internal" href="#sending-receiving-messages">Sending/receiving messages</a>.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>The <code class="docutils literal"><span class="pre">msg_name</span></code> field of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">msghdr</span></code> structure must be
initialized to the destination address (pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sockaddr</span></code>)
and the <code class="docutils literal"><span class="pre">msg_namelen</span></code> field to the address size.</p>
<p>Initialize the <code class="docutils literal"><span class="pre">msg_flags</span></code> field of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">msghdr</span></code> structure
to <code class="docutils literal"><span class="pre">0</span></code>.</p>
<p class="last">Initialize the <code class="docutils literal"><span class="pre">msg_control</span></code> and <code class="docutils literal"><span class="pre">msg_controllen</span></code> fields of the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">msghdr</span></code> structure to <code class="docutils literal"><span class="pre">NULL</span></code> and <code class="docutils literal"><span class="pre">0</span></code> respectively.</p>
</div>
<p>For sending the message use <code class="xref c c-func docutils literal"><span class="pre">kernel_sendmsg()</span></code>.</p>
<p>The message transmission parameters are retrieved from the kernel space. Cast
the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">iovec</span></code> structure pointer to a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kvec</span></code> pointer
in the <code class="xref c c-func docutils literal"><span class="pre">kernel_sendmsg()</span></code> call.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">The last two parameters of <code class="xref c c-func docutils literal"><span class="pre">kernel_sendmsg()</span></code> are <code class="docutils literal"><span class="pre">1</span></code> (number of I/O
vectors) and <code class="docutils literal"><span class="pre">len</span></code> (message size).</p>
</div>
<p>For testing, use the <code class="file docutils literal"><span class="pre">test-5.sh</span></code> file. The script is copied on the virtual
machine by the <strong class="command">make copy</strong> command only if it is marked as executable.
The script uses the statically compiled <code class="docutils literal"><span class="pre">netcat</span></code> tool stored in
<code class="file docutils literal"><span class="pre">skels/networking/netcat</span></code>; this executable must have execution
permissions.</p>
<p>For a correct implementation, running the <code class="file docutils literal"><span class="pre">test-5.sh</span></code> script will cause
the <code class="docutils literal"><span class="pre">kernelsocket</span></code> message to be displayed like in the output below:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">/root # ./test-5.sh</span>
<span class="go">+ pid=1059</span>
<span class="go">+ sleep 1</span>
<span class="go">+ nc -l -u -p 60001</span>
<span class="go">+ insmod udp_sock.ko</span>
<span class="go">kernelsocket</span>
<span class="go">+ rmmod udp_sock</span>
<span class="go">+ kill 1059</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="memory_mapping.html" class="btn btn-neutral float-right" title="Memory mapping" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="filesystems_part2.html" class="btn btn-neutral float-left" title="File system drivers (Part 2)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
